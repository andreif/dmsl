This project is a work in progress. Refer to test/templates/ for available syntax.
Follow development at http://github.com/dasacc22/DAML

To run unit tests:

.. sourcecode:: bash

  #> python test/

To use:

.. sourcecode:: python

  import daml
  daml._sandbox._open.template_dir = 'omg/seriously'
  daml.parse('index.daml', {'content': 'Hello World'})

Bugs and Feature Requests
=========================

If you are testing this library and would like to file a bug, use the Issues
section at github. Do the same with feature requests. Currently I am working
on a project and making use of daml, so for now I am simply writing down any
issues I come across in its use. Daml is most certainly not ready for anyone
to use in a production environment, it may have bug crippling problems. But
do feel free to play around with it :)

Speed Tests
===========

I used the speed test mentioned on Mako's website which is a benchmark found
in the Genshi repository. These are the current results as of Mon, 17 May and I
am listing this to show that DAML is quite fast for all that it's doing. (basic.py)

| Mako: 0.37 ms
| Daml: 0.41 ms
| Cheetah: 0.63 ms
| Genshi_text: 1.00 ms
| Django: 2.28 ms
| Genshi: 2.84 ms

Today, Mon, 17 May I ran the big_table.py benchmark on Daml and got a pretty
decent time of 147ms. Though I almost immediately realized why this kind of
evaluation was taking this long (iterating and handling list returns in the
slowest way possible) and fixed it immediately. Now, these are the results.

| Daml                                           27.21 ms
| Mako Template                                  53.76 ms
| Genshi tag builder                            483.61 ms
| Genshi template                               289.81 ms
| Genshi text template                          201.49 ms
| Genshi template + tag builder                 526.75 ms
| ElementTree                                   276.59 ms
| cElementTree                                  176.67 ms
| Djange template                               565.92 ms

It should be noted the actual output as of right now is errorneous due to
a pre_parser bug and nesting for loops. The error is that td's are not attached
to the tr parent, but rather the table. When this bug is fixed, it will not
have an impact on the performance seen above.

Notes on Security
=================

I am by no means an expert in this area. I would love to see this code reviewed
by more knowledgable people (once the code-base has been refactored).
The eval process is seperate from the document building process. Eval's
ussually take place once. The exception is if a function is written that calls
py_parse(which makes a call to a sandboxed eval) during a safe_eval. This happens with
builtins like `block` and `include` to process the documents python code. Never
is an eval of any sort called on any variables or dynamic content unless a
function is written otherwise. This would of course be a big NO-NO as one would
open themselves up to all sorts of malicious abuse. When writing custom
functions for the backend, avoid the use of py_parse unless you know what your
doing. Essentially, there should be no way for variable content to actually
call any function (and there isn't as far as I can tell due to its compile and
single eval).

XSS is another issue. Currently, any HTML embedded in the DAML document
will not be escaped and there is no need to mark it in a special way. Using
Formatter, one can declare {variable:safe} to not escape HTML content from a
variable. From there, any {variable} declared will be auto-escaped.

Explanation of Syntax Choices
=============================

First note, I've never actually used HAML or ruby for that matter beyond
writing a quick ruby profiler (and having to google how to write every single
line of the ruby code...) and using an example doc from their site. Point being
I may very well and very easily mis-state some aspect of HAML.

While the basic syntax choice to represent tags is the same as HAML, there are
some significant differences from there on. Specifically, I have chosen
syntaxes that are either, (a) already familiar with python users, or (b) found
to my liking in the HAML syntax as specified by their documentation.

As I went over the documentation and started
making choices for how to implement these various pieces, one of the first
choices I made was to unify much of the syntax.

The DAML Syntax
===============

This is pretty straight forward and deviates a little away from HAML when
declaring tag attributes. Tags are declared with % and if omitted, a div is
automatically used. You can use # and . and they mean the same just as the CSS
selectors. Here is a basic document.

.. sourcecode:: haml

  %html
      %head
          %title
      %body

          #header
              %h1 Welcome

          #content
              %p

          #footer

Also of note, it is ok to have variable indention just as in python. So
For example:

.. sourcecode:: haml

  %html
      %head
        %title
      %body
          #header
                  %p
          #content
              %a

Text has a few limitations at the moment which will be resolved shortly enough.
These limitations are white-space control and line escaping. Let's look at some
examples of using text in the document.

.. sourcecode:: haml

  %html
      %head
          %title Multiline Text
      %body
          %h1 Example of Multiline Text
          %p This paragraph will stretch across
              multiple lines and all of the line breaks
              are indented under the parent.

              .embedded This div is embedded in the paragraph
                  and also features multiline text in the
                  source document.

              This text tails the %div.embedded and just as well,
              features multiline text that is aligned appropriately
              to the <strong>previous<strong>.

          %p It's worth noting that
              %em new tags
              need to be on a new line for now but more then likely
              this will probably
              %strong remain the same
              and besides this should be written
              more along the lines of <em>new tags</em> anyway.

          %em#footer And there you have it.

Refer here for more info on what HAML style is good for (and not so good for):
http://chriseppstein.github.com/blog/2010/02/08/haml-sucks-for-content/

That about sums up basic text usage, more to be added as functionality
increases.

Calling Python Code
===================
To call any piece of python code, one simply uses the : directive.
The : directive can also be embedded in a line, but *only* for calling a
function. So for example, you can create blocks of python code as such

.. sourcecode:: haml

    # this example is currently broken
    :l = []
    :for x in range(10):
    :    l.append(x)

The variable l is accessible for use elsewhere in the document as well. In
addition to the example above, one can also write straight to the document
with a list comprehension.

.. sourcecode:: haml

    %ul
        :['%li {0}'.format(x) for x in l]

Note, the above is more of a side effect of implementation more so then a
planned feature. Everything is subject to change and still under heavy
development. Here is an example of defining a lambda function and embedding a
result somewhere

.. sourcecode:: haml

    :greet = lambda x: 'Hello, {0}'.format(x)

    %p :greet('John Doe'). Welcome to the site.

Also note you can define a regular function as well, for example:

.. sourcecode:: haml

    # this may be broken too
    :def greet(x):
    :    return 'Hello, {0}'.format(x)

The choice to follow python syntax for the
recent string.Formatter seemed like the most logical choice. Daml uses a
custom formatter that has access to the sandbox namespace and implements
two specs related to escaping/unescaping html.

.. sourcecode:: haml

    :title = 'Hello World!'
    :tag = 'this <strong> rocks'

    %h1 {title}
    %p Welcome to the site, {tag:safe}. We hope you enjoy.

Also now available are multiline function calls, where those multiple lines are
plain text. The first use of this is a django style :block directive. Take the
following for example:

.. sourcecode:: haml

  %html
      %body
          :block header
              %h1 Default Header
              .tagline Default Tagline

          :block content

          :block footer
              #footer Copyright Default
                  %p something to show multiple
                      and lines

Now what's really happening here is the parser translates the above to actually
look like this

.. sourcecode:: haml

  :block('\nheader\n%h1 Default Header\n.tagline Default Tagline\n')

and so on. This, with a few
other additions, will allow it to be easy to create custom text filters in
your server side code, so for example,

.. sourcecode:: python

  def block(s):
      s = s.splitlines()
      # do some processing stuff like reST transforms or w/e
      return s

Going back to the django blocks example, a document can then extend the
example given that looks like this

.. sourcecode:: haml

  :extends('name_of_doc.daml')

  :block header
      %h1 OVERRIDE

Also available now is the ability to mixed plain text content with python.
So for example

.. sourcecode:: haml

  :subs = ['www', 'js', 'gitview', 'vizi', 'music']

  .portal
      %ul
          :for x in subs:
              %li
                  %a(href=http://{x}.dasa.cc) {x}

      :if 't' == 't':
          %p HELLO

Currently this may feel a little odd. Essentially, content is aligned with its
nearest directive. So the %li would be aligned with the :for, and the %a then
with the %li. This syntax no doubt has its limitations as it has not been
thoroughly tested yet.

and as long as there aren't any bugs in the code ;) it works as expected. Keep
in mind this is still under heavy development and very young. There are
more examples under daml/test/templates.

Still more to come..
