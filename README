DAML
====

This project is a work in progress. Refer to test/templates/ for available syntax.
Follow development at http://github.com/dasacc22/DAML

To run unit tests:
#> python test/

To use:
import daml
daml._sandbox._open.template_dir = 'omg/seriously'
daml.parse('index.daml', {'content': 'Hello World'}

Speed Tests
===========

I used the speed test mentioned on Mako's website which is a benchmark found
in the Genshi repository. This are the current results as of Wed, 11 May and I
am listing this to show that DAML is quite fast for all that it's doing.

Mako: 0.37 ms
Daml: 0.48 ms
Cheetah: 0.63 ms
Genshi_text: 1.00 ms
Django: 2.28 ms
Genshi: 2.84 ms

Notes on Security
=================

I am by no means an expert in this area. I would love to see this code reviewed
by more knowledgable people (once the code-base has been refactored).
The eval process is seperate from the document building process. Eval's
ussually take place once. The exception is if a function is written that calls
py_parse(which makes a call to a sandboxed eval) during a safe_eval. This happens with
builtins like `block` and `include` to process the documents python code. Never
is an eval of any sort called on any variables or dynamic content unless a
function is written otherwise. This would of course be a big NO-NO as one would
open themselves up to all sorts of malicious abuse. When writing custom
functions for the backend, avoid the use of py_parse unless you know what your
doing. Essentially, there should be no way for variable content to actually
call any function (and there isn't as far as I can tell due to its compile and
single eval).

XSS is another issue. Currently, any HTML embedded in the DAML document
will not be escaped and there is no need to mark it in a special way. Using
Formatter, one can declare {variable:safe} to not escape HTML content from a
variable. From there, any {variable} declared will be auto-escaped.

Explanation of Syntax Choices
=============================

First note, I've never actually used HAML or ruby for that matter beyond
writing a quick ruby profiler (and having to google how to write every single
line of the ruby code...) and using an example doc from their site. Point being
I may very well and very easily mis-state some aspect of HAML.

While the basic syntax choice to represent tags is the same as HAML, there are
some significant differences from there on. Specifically, I have chosen
syntaxes that are either, (a) already familiar with python users, or (b) found
to my liking in the HAML syntax as specified by their documentation.

As I went over the documentation and started
making choices for how to implement these various pieces, one of the first
choices I made was to unify much of the syntax.

The DAML Syntax
===============

This is pretty straight forward and deviates a little away from HAML when
declaring tag attributes. Tags are declared with % and if omitted, a div is
automatically used. You can use # and . and they mean the same just as the CSS
selectors. Here is a basic document.

%html
    %head
        %title
    %body

        #header
            %h1 Welcome

        #content
            %p

        #footer

Also of not is that it is ok to have variable indention just as in python. So
For example:

%html
    %head
      %title
    %body
        #header
                %p
        #content
            %a

Text has a few limitations at the moment which will be resolved shortly enough.
These limitations are white-space control and line escaping. Let's look at some
examples of using text in the document.

%html
    %head
        %title Multiline Text
    %body
        %h1 Example of Multiline Text
        %p This paragraph will stretch across
            multiple lines and all of the line breaks
            are indented under the parent.

            .embedded This div is embedded in the paragraph
                and also features multiline text in the
                source document.

            This text tails the %div.embedded and just as well,
            features multiline text that is aligned appropriately
            to the <strong>previous<strong>.

        %p It's worth noting that
            %em new tags
            need to be on a new line for now but more then likely
            this will probably
            %strong remain the same
            and besides this should be written
            more along the lines of <em>new tags</em> anyway.

        %em#footer And there you have it.

Refer here for more info on what HAML style is good for (and not so good for):
http://chriseppstein.github.com/blog/2010/02/08/haml-sucks-for-content/

That about sums up basic text usage, more to be added as functionality
increases.

Calling Python Code
===================
To call any piece of python code, one simply uses the : directive.
The : directive can also be embedded in a line, but *only* for calling a
function. So for example, you can create blocks of python code as such

  # this example is currently broken
  :l = []
  :for x in range(10):
  :    l.append(x)

The variable l is accessible for use elsewhere in the document as well. In
addition to the example above, one can also write straight to the document
with a list comprehension.

  %ul
      :['%li {0}'.format(x) for x in l]

Note, the above is more of a side effect of implementation more so then a
planned feature. Everything is subject to change and still under heavy
development. Here is an example of defining a lambda function and embedding a
result somewhere

  :greet = lambda x: 'Hello, {0}'.format(x)

  %p :greet('John Doe'). Welcome to the site.

Also note you can define a regular function as well, for example:

  # this may be broken too
  :def greet(x):
  :    return 'Hello, {0}'.format(x)

The choice to follow python syntax for the
recent string.Formatter seemed like the most logical choice. Daml uses a
custom formatter that has access to the sandbox namespace and implements
two specs for related to escaping/or-not html.

  :title = 'Hello World!'
  :tag = 'this <strong> rocks'

  %h1 {title}
  %p Welcome to the site, {tag:safe}. We hope you enjoy.

Also now available are multiline function calls, where those multiple lines are
plain text. The first use of this is a django style :block directive. Take the
following for example:

%html
    %body
        :block header
            %h1 Default Header
            .tagline Default Tagline

        :block content

        :block footer
            #footer Copyright Default
                %p something to show multiple
                    and lines

Now what's really happening here is the parser translates the above to actually
look like this

:block('\nheader\n%h1 Default Header\n.tagline Default Tagline\n')

and so on. This, with a few
other additions, will allow it to be easy to create custom text filters in
your server side code, so for example,

def block(s):
    s = s.splitlines()
    # do some processing stuff like reST transforms or w/e
    return s

Going back to the django blocks example, a document can then extend the
example given that looks like this

:extends('name_of_doc.daml')

:block header
    %h1 OVERRIDE

Also available now is the ability to mixed plain text content with python.
So for example

:subs = ['www', 'js', 'gitview', 'vizi', 'music']

.portal
    %ul
        :for x in subs:
            %li
                %a(href=http://{x}.dasa.cc) {x}

    :if 't' == 't':
        %p HELLO

Currently this may feel a little odd. Essentially, content is aligned with its
nearest directive. So the %li would be aligned with the :for, and the %a then
with the %li. This syntax no doubt has its limitations as it has not been
thoroughly tested yet.

and as long as there aren't any bugs in the code ;) it works as expected. Keep
in mind this is still under heavy development and very young. There are
more examples under daml/test/templates.

Still more to come..
